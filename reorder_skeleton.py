# -*- coding: utf-8 -*-
"""reorder_skeleton.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GgaheKG109-9sRGfrihP47tunq29gd9d
"""

def reorder_skeleton(skel_coord):
  """
  Orders pixel locations for a skeletonized image in order from end to end.
  """

"""Takes in a list of coordinates for the skeleton 
of a skeletonized image. Using a machine learning 
algorithm from sklearn called NearestNeighbors, 
each pixel is connected to its two nearest 
neighboring pixels. Using networkx, a path is drawn
through each pixel, passing through each only once. 
Finally, a cost function that minimizes the path distance 
determines which pixels are at the ends of the skeleton.
The algorithm is limited to skeletons that are single 
lines without branches. The algorithm is adapted from one 
posted at this link: 

https://stackoverflow.com/questions/37742358/sorting-points-to-form-a-continuous-line

Parameters
----------
skel_coord : Nx2 float array
             data
             array of points for the skeleton of an image.
             In general, points tend to be obtained using 
             the np.argwhere function

Returns
-------
skel_end2end: Nx2 float array
              data
              all coordinates of the skeleton, ordered 
              in the way they appear on the image of the 
              skeleton, rather than the order output by 
              np.argwhere.
"""

def reorder_skeleton(skel_coord):

  # Run NearestNeighbors algorithm for nearest 2 points and create sparse matrix relating points
  skel_NN = NearestNeighbors(2).fit(skel_coord)
  skel_sparse = skel_NN.kneighbors_graph()

  # Generate network from sparse matrix
  skel_net = nx.from_scipy_sparse_matrix(skel_sparse)
  
  # Obtain all possible paths starting at each point that pass through all points on the skeleton once
  skel_paths = [list(nx.dfs_preorder_nodes(skel_net, i)) for i in range(len(skel_coord))]

  # Cost function to determine the shortest path through the points which will be endpoint to endpoint
  min_dist = np.inf
  skel_initx = 0
  
  for i in range(len(skel_coord)):

    p = skel_paths[i]
    skel_ordered = skel_coord[p]

    cost = (((skel_ordered[:-1] - skel_ordered[1:])**2).sum(1)).sum()

    if cost < min_dist:
      min_dist = cost
      skel_initx = i
    
  # Obtain optimal index order of 
  skel_optord = skel_paths[skel_initx]

  # Reorder skeleton using the optimal index order
  x = skel_coord[:,1]
  y = skel_coord[:,0]
  
  skel_end2end = skel_coord

  skel_end2end[:,1] = x[skel_optord]
  skel_end2end[:,0] = y[skel_optord]

  return skel_end2end

"""
Example
-------
import numpy as np
from scipy.spatial.distance import euclidean

from skimage.util import image_as_ubyte
from skimage.morphology import skeletonize

from sklearn.neighbors import NearestNeighbors
import networkx as nx

from google.colab import drive    # Code required to access files in google drive

drive.mount('/content/drive', force_remount=True)   # Mount google drive in order to access files

# Obtain image from google drive
im = img_as_ubyte(plt.imread('/content/drive/MyDrive/LilyData/tepal1.jpg'))
threshold = threshold_otsu(im[:,:,1])
im = im[:,:,1] > threshold

# Generate skeleton of image
im_s = skeletonize(im)

# Find all coordinates of skeleton
skel_coord = np.argwhere(im_s)

# Use function reorder_skeleton()
skel_ordered = reorder_skeleton(skel_coord)

"""